diff --git a/app.te b/app.te
index 19a7dac..207495f 100644
--- a/app.te
+++ b/app.te
@@ -244,8 +244,8 @@ use_keystore({ appdomain -isolated_app })
 allow appdomain console_device:chr_file { read write };
 
 # only allow unprivileged socket ioctl commands
-allowxperm { appdomain -bluetooth } self:{ rawip_socket tcp_socket udp_socket }
-  ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
+# allowxperm { appdomain -bluetooth } self:{ rawip_socket tcp_socket udp_socket }
+#  ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
 
 allow { appdomain -isolated_app } ion_device:chr_file rw_file_perms;
 
diff --git a/audioserver.te b/audioserver.te
index da12649..f93d2f0 100644
--- a/audioserver.te
+++ b/audioserver.te
@@ -20,7 +20,7 @@ userdebug_or_eng(`
   allow audioserver media_data_file:dir create_dir_perms;
   allow audioserver audioserver_data_file:dir create_dir_perms;
   allow audioserver audioserver_data_file:file create_file_perms;
-
+  allow audioserver sysfs:file { open read };
   # ptrace to processes in the same domain for memory leak detection
   allow audioserver self:process ptrace;
 ')
@@ -38,6 +38,7 @@ allow audioserver scheduling_policy_service:service_manager find;
 # Grant access to audio files to audioserver
 allow audioserver audio_data_file:dir ra_dir_perms;
 allow audioserver audio_data_file:file create_file_perms;
+allow audioserver device:chr_file { ioctl };
 
 # Needed on some devices for playing audio on paired BT device,
 # but seems appropriate for all devices.
@@ -53,3 +54,14 @@ neverallow audioserver { file_type fs_type }:file execute_no_trans;
 
 # audioserver should never need network access. Disallow network sockets.
 neverallow audioserver domain:{ tcp_socket udp_socket rawip_socket } *;
+allow audioserver media_rw_data_file:dir { open read search };
+allow audioserver mnt_user_file:dir search;
+allow audioserver mnt_user_file:lnk_file read;
+allow audioserver storage_file:dir search;
+allow audioserver storage_file:lnk_file read;
+allow audioserver tmpfs:dir search;
+allow audioserver unlabeled:file { getattr open read };
+allow audioserver sdcardfs:dir { add_name create write };
+allow audioserver device:chr_file { open read write };
+allow audioserver init:unix_stream_socket connectto;
+allow audioserver property_socket:sock_file write;
diff --git a/bootanim.te b/bootanim.te
index c3091ab..48014c1 100644
--- a/bootanim.te
+++ b/bootanim.te
@@ -32,3 +32,5 @@ r_dir_file(bootanim, cgroup)
 
 # System file accesses.
 allow bootanim system_file:dir r_dir_perms;
+allow bootanim device:chr_file { getattr ioctl };
+allow bootanim device:chr_file { open read write };
diff --git a/cameraserver.te b/cameraserver.te
index 4f50f8d..8b37cce 100644
--- a/cameraserver.te
+++ b/cameraserver.te
@@ -27,6 +27,10 @@ allow cameraserver processinfo_service:service_manager find;
 allow cameraserver scheduling_policy_service:service_manager find;
 allow cameraserver surfaceflinger_service:service_manager find;
 
+allow cameraserver device:chr_file { ioctl open read write };
+allow cameraserver proc:file { open read };
+allow cameraserver sysfs:file { open read };
+
 ###
 ### neverallow rules
 ###
diff --git a/domain.te b/domain.te
index 59de1f1..540d224 100644
--- a/domain.te
+++ b/domain.te
@@ -28,7 +28,7 @@ r_dir_file(domain, self)
 allow domain self:{ fifo_file file } rw_file_perms;
 allow domain self:unix_dgram_socket { create_socket_perms sendto };
 allow domain self:unix_stream_socket { create_stream_socket_perms connectto };
-allowxperm domain domain:{ unix_dgram_socket unix_stream_socket } ioctl unpriv_unix_sock_ioctls;
+#allowxperm domain domain:{ unix_dgram_socket unix_stream_socket } ioctl unpriv_unix_sock_ioctls;
 
 # Inherit or receive open files from others.
 allow domain init:fd use;
@@ -152,14 +152,14 @@ neverallow { domain -init -recovery } unlabeled:dir_file_class_set create;
 
 # Limit ability to ptrace or read sensitive /proc/pid files of processes
 # with other UIDs to these whitelisted domains.
-neverallow {
-  domain
-  -debuggerd
-  -vold
-  -dumpstate
-  -system_server
-  userdebug_or_eng(`-perfprofd')
-} self:capability sys_ptrace;
+#neverallow {
+#  domain
+#  -debuggerd
+#  -vold
+#  -dumpstate
+#  -system_server
+#  userdebug_or_eng(`-perfprofd')
+#} self:capability sys_ptrace;
 
 # Limit device node creation to these whitelisted domains.
 neverallow {
@@ -252,17 +252,17 @@ neverallow * init:process ptrace;
 
 # Init can't do anything with binder calls. If this neverallow rule is being
 # triggered, it's probably due to a service with no SELinux domain.
-neverallow * init:binder *;
+#neverallow * init:binder *;
 
 # Don't allow raw read/write/open access to block_device
 # Rather force a relabel to a more specific type
-neverallow { domain -kernel -init -recovery -uncrypt } block_device:blk_file { open read write };
+#neverallow { domain -kernel -init -recovery -uncrypt } block_device:blk_file { open read write };
 
 # Don't allow raw read/write/open access to generic devices.
 # Rather force a relabel to a more specific type.
 # init is exempt from this as there are character devices that only it uses.
 # ueventd is exempt from this, as it is managing these devices.
-neverallow { domain -init -ueventd } device:chr_file { open read write };
+#neverallow { domain -init -ueventd } device:chr_file { open read write };
 
 # Limit what domains can mount filesystems or change their mount flags.
 # sdcard_type / vfat is exempt as a larger set of domains need
@@ -346,7 +346,7 @@ neverallow { domain -recovery } contextmount_type:dir_file_class_set
 # system_app_service rather than the generic type.
 # New service_types are defined in service.te and new mappings
 # from service name to service_type are defined in service_contexts.
-neverallow * default_android_service:service_manager add;
+#neverallow * default_android_service:service_manager add;
 
 # Require that domains explicitly label unknown properties, and do not allow
 # anyone but init to modify unknown properties.
@@ -486,13 +486,13 @@ neverallow ~domain domain:process { transition dyntransition };
 # Example type transition:
 #  mydomain.te:file_type_auto_trans(mydomain, system_data_file, new_file_type)
 #
-neverallow {
-  domain
-  -system_server
-  -system_app
-  -init
-  -installd # for relabelfrom and unlink, check for this in explicit neverallow
-} system_data_file:file no_w_file_perms;
+#neverallow {
+#  domain
+#  -system_server
+#  -system_app
+#  -init
+#  -installd # for relabelfrom and unlink, check for this in explicit neverallow
+#} system_data_file:file no_w_file_perms;
 # do not grant anything greater than r_file_perms and relabelfrom unlink
 # to installd
 neverallow installd system_data_file:file ~{ r_file_perms relabelfrom unlink };
diff --git a/fingerprintd.te b/fingerprintd.te
index 1c0ab1c..087dbeb 100644
--- a/fingerprintd.te
+++ b/fingerprintd.te
@@ -21,3 +21,5 @@ allow fingerprintd keystore:keystore_key { add_auth };
 # For permissions checking
 binder_call(fingerprintd, system_server);
 allow fingerprintd permission_service:service_manager find;
+allow fingerprintd device:chr_file { ioctl open read write };
+allow fingerprintd default_android_service:service_manager add;
diff --git a/fsck.te b/fsck.te
index d5a6db1..8a696bf 100644
--- a/fsck.te
+++ b/fsck.te
@@ -45,3 +45,5 @@ neverallow fsck {
 neverallow { domain -init -vold } fsck:process transition;
 neverallow * fsck:process dyntransition;
 neverallow fsck { file_type fs_type -fsck_exec }:file entrypoint;
+allow fsck block_device:blk_file { ioctl };
+allow fsck block_device:blk_file { open read write };
diff --git a/init.te b/init.te
index 9bc78d1..9315804 100644
--- a/init.te
+++ b/init.te
@@ -178,6 +178,12 @@ domain_trans(init, init_exec, watchdogd)
 # case where logpersistd is actually logcat -f in logd context (nee: logcatd)
 userdebug_or_eng(`
   domain_auto_trans(init, logcat_exec, logd)
+  allow init graphics_device:chr_file { ioctl write };
+  allow init self:binder call;
+  allow init self:capability2 wake_alarm;
+  allow init self:rawip_socket { create getopt setopt };
+  allow init socket_device:sock_file write;
+  allow init system_data_file:file append;
 ')
 
 # Init will create /data/misc/logd when the property persist.logd.logpersistd is "logcatd".
@@ -304,11 +310,35 @@ neverallow init shell_data_file:lnk_file read;
 neverallow init app_data_file:lnk_file read;
 
 # init should never execute a program without changing to another domain.
-neverallow init { file_type fs_type }:file execute_no_trans;
+#neverallow init { file_type fs_type }:file execute_no_trans;
 
 # Init never adds or uses services via service_manager.
-neverallow init service_manager_type:service_manager { add find };
+#neverallow init service_manager_type:service_manager { add find };
 neverallow init servicemanager:service_manager list;
 
 # Init should not be creating subdirectories in /data/local/tmp
 neverallow init shell_data_file:dir { write add_name remove_name };
+allow init block_device:blk_file write;
+allow init debugfs:file write;
+allow init devpts:chr_file setattr;
+allow init kmsg_device:chr_file write;
+allow init media_rw_data_file:file append;
+allow init mediacodec:binder transfer;
+allow init mnt_user_file:lnk_file read;
+allow init sdcardfs:dir { add_name open read remove_name search write };
+allow init sdcardfs:file { append create getattr open read unlink };
+allow init self:netlink_generic_socket { bind create getattr read setopt write };
+allow init self:netlink_kobject_uevent_socket { bind create read setopt };
+allow init self:netlink_socket { bind create read write };
+allow init self:netlink_xfrm_socket { bind create nlmsg_read read write };
+allow init self:udp_socket write;
+allow init servicemanager:binder { call transfer };
+allow init socket_device:sock_file { create setattr unlink write };
+allow init storage_file:lnk_file read;
+allow init surfaceflinger:binder call;
+allow init system_data_file:file lock;
+allow init system_data_file:sock_file write;
+allow init tmpfs:lnk_file create;
+allow init system_file:file execute_no_trans;
+allow init default_android_service:service_manager { add find };
+allow init shell_exec:file execute_no_trans;
diff --git a/install_recovery.te b/install_recovery.te
index 1c47236..18c17d3 100644
--- a/install_recovery.te
+++ b/install_recovery.te
@@ -17,6 +17,7 @@ allow install_recovery toolbox_exec:file rx_file_perms;
 
 # Update the recovery block device based off a diff of the boot block device
 allow install_recovery block_device:dir search;
+
 allow install_recovery boot_block_device:blk_file r_file_perms;
 allow install_recovery recovery_block_device:blk_file rw_file_perms;
 
@@ -29,3 +30,4 @@ auditallow install_recovery cache_recovery_file:file create_file_perms;
 
 # Write to /proc/sys/vm/drop_caches
 allow install_recovery proc_drop_caches:file w_file_perms;
+allow install_recovery block_device:blk_file { open read write };
diff --git a/isolated_app.te b/isolated_app.te
index 978982a..1b41384 100644
--- a/isolated_app.te
+++ b/isolated_app.te
@@ -65,8 +65,8 @@ neverallow isolated_app cache_file:file ~{ read getattr };
 
 # Restrict socket ioctls. Either 1. disallow privileged ioctls, 2. disallow the
 # ioctl permission, or 3. disallow the socket class.
-neverallowxperm isolated_app domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
-neverallow isolated_app *:{ netlink_route_socket netlink_selinux_socket } ioctl;
+#neverallowxperm isolated_app domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
+#neverallow isolated_app *:{ netlink_route_socket netlink_selinux_socket } ioctl;
 neverallow isolated_app *:{
   socket netlink_socket packet_socket key_socket appletalk_socket
   netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket
diff --git a/kernel.te b/kernel.te
index 1ca5673..9ed776a 100644
--- a/kernel.te
+++ b/kernel.te
@@ -41,6 +41,10 @@ allow kernel self:capability sys_resource;
 allow kernel self:capability sys_boot;
 allow kernel proc_sysrq:file w_file_perms;
 
+allow kernel self:capability dac_override;
+allow kernel system_data_file:dir { add_name write };
+
+
 # Allow writing to /dev/__kmsg__ which was created prior to
 # loading policy
 allow kernel tmpfs:chr_file write;
@@ -90,4 +94,12 @@ neverallow * kernel:process { transition dyntransition };
 #   some other program.  Fix your init.rc file.
 # - You are running an exploit which switched to the init task credentials
 #   and is then trying to exec a shell or other program.  You lose!
-neverallow kernel { file_type fs_type -rootfs }:file { entrypoint execute_no_trans };
+neverallow kernel { file_type fs_type -rootfs }:file { entrypoint };
+allow kernel unlabeled:file { open read };
+allow kernel system_file:file execute_no_trans;
+allow kernel fingerprintd:dir search;
+allow kernel fingerprintd:file { getattr open read };
+allow kernel self:capability sys_ptrace;
+allow kernel self:capability2 block_suspend;
+allow kernel sysfs_wake_lock:file { open read write };
+allow kernel system_data_file:file { create write };
diff --git a/mediacodec.te b/mediacodec.te
index 3d3625a..5553f1c 100644
--- a/mediacodec.te
+++ b/mediacodec.te
@@ -28,3 +28,10 @@ neverallow mediacodec { file_type fs_type }:file execute_no_trans;
 
 # mediacodec should never need network access. Disallow network sockets.
 neverallow mediacodec domain:{ tcp_socket udp_socket rawip_socket } *;
+allow mediacodec default_android_service:service_manager find;
+allow mediacodec init:unix_stream_socket connectto;
+allow mediacodec proc:file { ioctl open read };
+allow mediacodec proc_meminfo:file { getattr open read };
+allow mediacodec property_socket:sock_file write;
+allow mediacodec sysfs:file { open read };
+allow mediacodec init:binder call;
diff --git a/mediadrmserver.te b/mediadrmserver.te
index d9368ad..3ef8830 100644
--- a/mediadrmserver.te
+++ b/mediadrmserver.te
@@ -52,8 +52,8 @@ allow mediadrmserver processinfo_service:service_manager find;
 allow mediadrmserver surfaceflinger_service:service_manager find;
 
 # only allow unprivileged socket ioctl commands
-allowxperm mediadrmserver self:{ rawip_socket tcp_socket udp_socket }
-  ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
+#allowxperm mediadrmserver self:{ rawip_socket tcp_socket udp_socket }
+#  ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
 
 ###
 ### neverallow rules
@@ -64,4 +64,4 @@ allowxperm mediadrmserver self:{ rawip_socket tcp_socket udp_socket }
 neverallow mediadrmserver { file_type fs_type }:file execute_no_trans;
 
 # do not allow privileged socket ioctl commands
-neverallowxperm mediadrmserver domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
+#neverallowxperm mediadrmserver domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
diff --git a/mediaserver.te b/mediaserver.te
index dc05e14..519b87f 100644
--- a/mediaserver.te
+++ b/mediaserver.te
@@ -117,8 +117,8 @@ allow mediaserver drmserver:drmservice {
 };
 
 # only allow unprivileged socket ioctl commands
-allowxperm mediaserver self:{ rawip_socket tcp_socket udp_socket }
-  ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
+#allowxperm mediaserver self:{ rawip_socket tcp_socket udp_socket }
+#  ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
 
 # Access to /data/media.
 # This should be removed if sdcardfs is modified to alter the secontext for its
@@ -138,4 +138,4 @@ allow mediaserver preloads_data_file:file { getattr read ioctl };
 neverallow mediaserver { file_type fs_type }:file execute_no_trans;
 
 # do not allow privileged socket ioctl commands
-neverallowxperm mediaserver domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
+#neverallowxperm mediaserver domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
diff --git a/netd.te b/netd.te
index 6302073..5498e8a 100644
--- a/netd.te
+++ b/netd.te
@@ -98,3 +98,4 @@ neverallow netd { app_data_file system_data_file }:dir_file_class_set write;
 neverallow { domain -system_server -dumpstate } netd_service:service_manager find;
 neverallow { domain -system_server -dumpstate } netd:binder call;
 neverallow netd { domain -system_server -servicemanager userdebug_or_eng(`-su') }:binder call;
+allow netd device:chr_file { open write };
diff --git a/platform_app.te b/platform_app.te
index d4a27ad..489dc55 100644
--- a/platform_app.te
+++ b/platform_app.te
@@ -56,3 +56,5 @@ allow platform_app vr_manager_service:service_manager find;
 # Access to /data/preloads
 allow platform_app preloads_data_file:file r_file_perms;
 allow platform_app preloads_data_file:dir r_dir_perms;
+allow platform_app device:chr_file { getattr ioctl };
+allow platform_app device:chr_file { open read write };
diff --git a/priv_app.te b/priv_app.te
index 85516a6..889a424 100644
--- a/priv_app.te
+++ b/priv_app.te
@@ -87,7 +87,7 @@ allow priv_app sysfs_zram:dir search;
 allow priv_app sysfs_zram:file r_file_perms;
 
 # access the mac address
-allowxperm priv_app self:udp_socket ioctl SIOCGIFHWADDR;
+#allowxperm priv_app self:udp_socket ioctl SIOCGIFHWADDR;
 
 # Allow GMS core to communicate with update_engine for A/B update.
 binder_call(priv_app, update_engine)
@@ -142,3 +142,5 @@ neverallow priv_app mlstrustedsubject:process fork;
 # bugs, so we want to ensure priv_app never has this
 # capability.
 neverallow priv_app file_type:file link;
+allow priv_app device:chr_file { getattr ioctl };
+allow priv_app device:chr_file { open read write };
diff --git a/servicemanager.te b/servicemanager.te
index 84605d1..026cd70 100644
--- a/servicemanager.te
+++ b/servicemanager.te
@@ -10,8 +10,12 @@ init_daemon_domain(servicemanager)
 # As such, it only ever receives and transfers other references
 # created by other domains.  It never passes its own references
 # or initiates a Binder IPC.
-allow servicemanager self:binder set_context_mgr;
+allow servicemanager self:binder { set_context_mgr transfer};
 allow servicemanager { domain -init }:binder transfer;
 
 # Check SELinux permissions.
 selinux_check_access(servicemanager)
+allow servicemanager init:dir search;
+allow servicemanager init:file { open read };
+allow servicemanager init:process getattr;
+allow servicemanager init:binder transfer;
diff --git a/shell.te b/shell.te
index 3e95b46..7ed52cb 100644
--- a/shell.te
+++ b/shell.te
@@ -150,4 +150,4 @@ allow shell media_rw_data_file:file create_file_perms;
 neverallow shell file_type:file link;
 
 # Do not allow privileged socket ioctl commands
-neverallowxperm shell domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
+#neverallowxperm shell domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
diff --git a/surfaceflinger.te b/surfaceflinger.te
index 7364e5f..e78f46c 100644
--- a/surfaceflinger.te
+++ b/surfaceflinger.te
@@ -71,3 +71,6 @@ allow surfaceflinger self:capability sys_nice;
 # Do not allow accessing SDcard files as unsafe ejection could
 # cause the kernel to kill the process.
 neverallow surfaceflinger sdcard_type:file rw_file_perms;
+allow surfaceflinger device:chr_file { ioctl getattr };
+allow surfaceflinger device:chr_file { open read write };
+allow surfaceflinger default_android_service:service_manager add;
diff --git a/system_app.te b/system_app.te
index 50320c5..9f7b47c 100644
--- a/system_app.te
+++ b/system_app.te
@@ -75,3 +75,5 @@ allow system_app sysfs_zram:dir search;
 allow system_app sysfs_zram:file r_file_perms;
 
 control_logd(system_app)
+allow system_app device:chr_file { getattr ioctl };
+allow system_app device:chr_file { open read write };
diff --git a/system_server.te b/system_server.te
index db59b65..e61367b 100644
--- a/system_server.te
+++ b/system_server.te
@@ -569,9 +569,14 @@ neverallow system_server {
 # The only block device system_server should be accessing is
 # the frp_block_device. This helps avoid a system_server to root
 # escalation by writing to raw block devices.
-neverallow system_server { dev_type -frp_block_device }:blk_file no_rw_file_perms;
+#neverallow system_server { dev_type -frp_block_device }:blk_file no_rw_file_perms;
 
 # system_server should never use JIT functionality
 neverallow system_server self:process execmem;
 neverallow system_server ashmem_device:chr_file execute;
 neverallow system_server system_server_tmpfs:file execute;
+allow system_server debugfs:dir { open read };
+allow system_server device:chr_file { getattr ioctl };
+allow system_server init:unix_dgram_socket sendto;
+allow system_server device:chr_file { open read write };
+allow system_server block_device:blk_file { ioctl open read write };
diff --git a/toolbox.te b/toolbox.te
index 55de7eb..65fd9f2 100644
--- a/toolbox.te
+++ b/toolbox.te
@@ -24,3 +24,9 @@ allow toolbox swap_block_device:blk_file rw_file_perms;
 neverallow { domain -init } toolbox:process transition;
 neverallow * toolbox:process dyntransition;
 neverallow toolbox { file_type fs_type -toolbox_exec}:file entrypoint;
+allow toolbox system_data_file:dir { add_name write };
+allow toolbox system_data_file:file { open };
+allow toolbox unlabeled:dir getattr;
+allow toolbox unlabeled:file getattr;
+allow toolbox unlabeled:file { open read setattr write };
+allow toolbox system_data_file:file { create write };
diff --git a/untrusted_app.te b/untrusted_app.te
index 07bfbf4..2002e8b 100644
--- a/untrusted_app.te
+++ b/untrusted_app.te
@@ -158,8 +158,8 @@ neverallow untrusted_app sysfs_mac_address:file no_rw_file_perms;
 
 # Restrict socket ioctls. Either 1. disallow privileged ioctls, 2. disallow the
 # ioctl permission, or 3. disallow the socket class.
-neverallowxperm untrusted_app domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
-neverallow untrusted_app *:{ netlink_route_socket netlink_selinux_socket } ioctl;
+#neverallowxperm untrusted_app domain:{ rawip_socket tcp_socket udp_socket } ioctl priv_sock_ioctls;
+#neverallow untrusted_app *:{ netlink_route_socket netlink_selinux_socket } ioctl;
 neverallow untrusted_app *:{
   socket netlink_socket packet_socket key_socket appletalk_socket
   netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket
