diff --git a/media/libeffects/testlibs/Android.mk b/media/libeffects/testlibs/Android.mk
new file mode 100644
index 000000000..14c373fb9
--- /dev/null
+++ b/media/libeffects/testlibs/Android.mk
@@ -0,0 +1,55 @@
+LOCAL_PATH:= $(call my-dir)
+
+# Test Reverb library
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	EffectReverb.c.arm \
+	EffectsMath.c.arm
+
+LOCAL_CFLAGS := -O2
+
+LOCAL_SHARED_LIBRARIES := \
+	libcutils \
+	libdl
+
+LOCAL_MODULE_RELATIVE_PATH := soundfx
+LOCAL_MODULE := libreverbtest
+
+LOCAL_C_INCLUDES := \
+	$(call include-path-for, audio-effects) \
+	$(call include-path-for, graphics corecg)
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
+
+# Test Equalizer library
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	EffectsMath.c.arm \
+	EffectEqualizer.cpp \
+	AudioBiquadFilter.cpp.arm \
+	AudioCoefInterpolator.cpp.arm \
+	AudioPeakingFilter.cpp.arm \
+	AudioShelvingFilter.cpp.arm \
+	AudioEqualizer.cpp.arm
+
+LOCAL_CFLAGS := -O2
+
+LOCAL_SHARED_LIBRARIES := \
+	libcutils \
+	libdl
+
+LOCAL_MODULE_RELATIVE_PATH := soundfx
+LOCAL_MODULE := libequalizertest
+
+LOCAL_C_INCLUDES := \
+	$(call include-path-for, graphics corecg) \
+	$(call include-path-for, audio-effects)
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
+
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index df4e4b6f6..3a068ef26 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -7,7 +7,7 @@ LOCAL_SRC_FILES:= \
 LOCAL_MODULE:= libmedia_helper
 LOCAL_MODULE_TAGS := optional
 
-LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
+LOCAL_CFLAGS += -Wno-error=deprecated-declarations -Wall
 LOCAL_CLANG := true
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libmedia/mtkaudio_stubs.cpp b/media/libmedia/mtkaudio_stubs.cpp
new file mode 100755
index 000000000..ab07ed5ad
--- /dev/null
+++ b/media/libmedia/mtkaudio_stubs.cpp
@@ -0,0 +1,64 @@
+#include <system/audio.h>
+#include <media/IAudioFlinger.h>
+#include <hardware/audio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+
+#ifndef __unused
+#define __unused  __attribute__((__unused__))
+#endif
+
+namespace android {
+
+class AudioSystem
+{
+public:
+    static bool getVoiceUnlockDLInstance();
+    static int GetVoiceUnlockDLLatency();
+    static int SetVoiceUnlockSRC(uint outSR, uint outChannel);
+    static bool stopVoiceUnlockDL();
+    static bool startVoiceUnlockDL();
+    static int ReadRefFromRing(void* buf, uint32_t datasz, void* DLtime);
+    static int GetVoiceUnlockULTime(void* DLtime);
+    static void freeVoiceUnlockDLInstance();
+
+}; // class
+
+bool AudioSystem::getVoiceUnlockDLInstance()
+{
+  return false;
+}
+
+int AudioSystem::GetVoiceUnlockDLLatency()
+{
+  return 0;
+}
+
+int AudioSystem::SetVoiceUnlockSRC(uint outSR __unused, uint outChannel __unused)
+{
+  return 0;
+}
+
+bool AudioSystem::stopVoiceUnlockDL()
+{
+  return false;
+}
+
+bool AudioSystem::startVoiceUnlockDL()
+{
+  return false;
+}
+
+int AudioSystem::ReadRefFromRing(void* buf __unused, uint32_t datasz __unused, void* DLtime __unused)
+{
+  return 0;
+}
+
+int AudioSystem::GetVoiceUnlockULTime(void* DLtime __unused)
+{
+  return 0;
+}
+
+void AudioSystem::freeVoiceUnlockDLInstance() {}
+
+} // namespace
diff --git a/media/libstagefright/foundation/MediaBufferGroup.cpp b/media/libstagefright/foundation/MediaBufferGroup.cpp
index 54f768af0..d7e6201bd 100644
--- a/media/libstagefright/foundation/MediaBufferGroup.cpp
+++ b/media/libstagefright/foundation/MediaBufferGroup.cpp
@@ -107,6 +107,21 @@ void MediaBufferGroup::add_buffer(MediaBuffer *buffer) {
     // optionally: mGrowthLimit = max(mGrowthLimit, mBuffers.size());
 }
 
+// stagefright: add mising MediaBufferGroup::acquire_buffer symbol - https://review.cyanogenmod.org/#/c/77502/
+extern "C" status_t _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferE(
+                    MediaBufferGroup* group, MediaBuffer **out) {
+    ALOGD("[Decker] _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferE");
+    return group->acquire_buffer(out, false, 0);
+}
+
+// just another method fix
+extern "C" status_t _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferEb(
+                    MediaBufferGroup* group, MediaBuffer **out, bool nonBlocking) {
+    ALOGD("[Decker] _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferEb");
+    return group->acquire_buffer(out, nonBlocking, 0);
+}
+
+
 bool MediaBufferGroup::has_buffers() {
     if (mBuffers.size() < mGrowthLimit) {
         return true; // We can add more buffers internally.
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index facfc860c..9cafb57cc 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -6469,20 +6469,20 @@ reacquire_wakelock:
         mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_SERVER] = systemTime();
 
         // Update server timestamp with kernel stats
-        if (mInput->stream->get_capture_position != nullptr
-                && mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
-            int64_t position, time;
-            int ret = mInput->stream->get_capture_position(mInput->stream, &position, &time);
-            if (ret == NO_ERROR) {
-                mTimestamp.mPosition[ExtendedTimestamp::LOCATION_KERNEL] = position;
-                mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_KERNEL] = time;
-                // Note: In general record buffers should tend to be empty in
-                // a properly running pipeline.
-                //
-                // Also, it is not advantageous to call get_presentation_position during the read
-                // as the read obtains a lock, preventing the timestamp call from executing.
-            }
-        }
+//        if (mInput->stream->get_capture_position != nullptr
+//                && mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
+//           int64_t position, time;
+//            int ret = mInput->stream->get_capture_position(mInput->stream, &position, &time);
+//            if (ret == NO_ERROR) {
+//                mTimestamp.mPosition[ExtendedTimestamp::LOCATION_KERNEL] = position;
+//                mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_KERNEL] = time;
+//                // Note: In general record buffers should tend to be empty in
+//                // a properly running pipeline.
+//                //
+//                // Also, it is not advantageous to call get_presentation_position during the read
+//                // as the read obtains a lock, preventing the timestamp call from executing.
+//            }
+//        }
         // Use this to track timestamp information
         // ALOGD("%s", mTimestamp.toString().c_str());
 
